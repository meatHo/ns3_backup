

#include "ns3/antenna-module.h"
#include "ns3/applications-module.h"
#include "ns3/cc-bwp-helper.h"
#include "ns3/config-store-module.h"
#include "ns3/config-store.h"
#include "ns3/core-module.h"
#include "ns3/epc-tft.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/ideal-beamforming-algorithm.h"
#include "ns3/internet-apps-module.h"
#include "ns3/internet-module.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/log.h"
#include "ns3/mobility-helper.h"
#include "ns3/mobility-module.h"
#include "ns3/network-module.h"
#include "ns3/nr-helper.h"
#include "ns3/nr-mac-scheduler-tdma-rr.h"
#include "ns3/nr-module.h"
#include "ns3/nr-point-to-point-epc-helper.h"
#include "ns3/point-to-point-helper.h"
#include "ns3/point-to-point-module.h"

#include <cmath>
using namespace ns3;

void
UeMeasCallback(uint16_t rnti,
               uint16_t cellId,
               double rsrp,
               double rsrq,
               bool isServingCell,
               uint8_t componentCarrierId)
{
    std::cout << "ğŸ“¶ [Meas] RNTI=" << rnti << " CellId=" << cellId
              << (isServingCell ? " (S)" : " (N)") << "  RSRP=" << rsrp << " dBm,"
              << " RSRQ=" << rsrq << " dB\n";
}

int
main(int argc, char* argv[])
{
    // LogComponentEnable("NrUeRrc", LOG_LEVEL_FUNCTION);
    // LogComponentEnable("NrHelper", LOG_LEVEL_FUNCTION);
    // LogComponentEnable("NrUeRrc", LOG_LEVEL_FUNCTION);  // Check UE RRC behavior
    // LogComponentEnable("NrGnbRrc", LOG_LEVEL_FUNCTION); // Check gNB RRC behavior
    uint16_t gNbNum = 2;
    uint16_t ueNum = 1;

    // ands = 1;
    double centralFrequencyBand = 3.5e9;
    // double bandwidthBand = 3e9;//3ê¸°ê°€ í—¤ë¥´ì¦ˆ
    double bandwidthBand = 1e8; // 100 MHz

    uint16_t numerology = 0;
    // SCSì„¤ì • 0=15kHz 3=120kHz
    //---------------------------------------------------------------------------
    NodeContainer gNbNodes;
    NodeContainer ueNodes;

    double gNbHeight = 10;
    double ueHeight = 10;

    gNbNodes.Create(gNbNum);
    ueNodes.Create(ueNum);

    Ptr<ListPositionAllocator> apPositionAlloc =
        CreateObject<ListPositionAllocator>(); // gnbìœ„ì¹˜ ì €ì¥
    Ptr<ListPositionAllocator> uePositionAlloc =
        CreateObject<ListPositionAllocator>(); // ueìœ„ì¹˜ ì €ì¥

    // x y z meterë‹¨ìœ„
    //  gnb---------gnb
    //  ue ->->->->->
    apPositionAlloc->Add(Vector(0.0, 0.0, gNbHeight));
    apPositionAlloc->Add(Vector(10.0, 0.0, gNbHeight));
    uePositionAlloc->Add(Vector(0.0, 0.0, ueHeight));

    // ìœ„ì¹˜ ì„¤ì •
    MobilityHelper mobility;
    mobility.SetMobilityModel("ns3::ConstantVelocityMobilityModel");

    MobilityHelper mobility_gnb;
    mobility_gnb.SetMobilityModel("ns3::ConstantPositionMobilityModel");

    mobility_gnb.SetPositionAllocator(apPositionAlloc);
    mobility_gnb.Install(gNbNodes);

    mobility.SetPositionAllocator(uePositionAlloc);
    mobility.Install(ueNodes);
    // ì—¬ê¸° ìœ„ëŠ” ì´ˆê¸° ìœ„ë¥¼ ì„¤ì •
    // ë°‘ì—ëŠ” ì´ë™

    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)
    {
        Ptr<Node> node = ueNodes.Get(i);
        Ptr<ConstantVelocityMobilityModel> mobility =
            node->GetObject<ConstantVelocityMobilityModel>();
        mobility->SetVelocity(Vector(1.0, 0.0, 0.0)); // xì¶•ìœ¼ë¡œ 1m/s
    }

    //==============================UE, gNB ìœ„ì¹˜ ì„¤ì •==================

    // setup the nr simulation
    Ptr<NrPointToPointEpcHelper> nrEpcHelper = CreateObject<NrPointToPointEpcHelper>();
    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();
    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();

    nrHelper->SetBeamformingHelper(idealBeamformingHelper);
    nrHelper->SetEpcHelper(nrEpcHelper);

    // Handover algorithm ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ìˆ˜ë™ ë°©ì‹
    // Ptr<NrA3RsrpHandoverAlgorithm> algo = CreateObject<NrA3RsrpHandoverAlgorithm>();
    // (ì›í•œë‹¤ë©´ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ë‚˜ TTT ê°™ì€ ì†ì„± ì¡°ì •)
    // algo->SetAttribute("Hysteresis", DoubleValue(3.0));
    // algo->SetAttribute("TimeToTrigger", TimeValue(MilliSeconds(256)));

    // Or a more typical value like 3.0 dB if desired:
    // nrHelper->SetHandoverAlgorithmAttribute("A3Offset", DoubleValue(3.0));

    // bwp ì„¤ì •, ë¶€íŒŒìˆ˜ ë¶„í• , Component Carrier
    /*
     * Setup the configuration of the spectrum. There is a contiguous and a non-contiguous
     * example:
     * 1) One operation band is deployed with 4 contiguous component carriers
     *    (CC)s, which are automatically generated by the ccBwpManager
     * 2) One operation bands non-contiguous case. CCs and BWPs are manually created
     */
    // contiguousëŠ” ì—°ì†ëœ ì£¼íŒŒìˆ˜ ëŒ€ì—­ìœ¼ë¡œ ìë™êµ¬ì„±í•  ë•Œ
    // non-contiguousëŠ” ìˆ˜ë™ìœ¼ë¡œ CC+BWPì„¤ì •(cttc-nr-cc-bwp-demo.cc ì°¸ê³ )

    BandwidthPartInfoPtrVector allBwps;
    CcBwpCreator ccBwpCreator;

    OperationBandInfo band;

    // For the case of manual configuration of CCs and BWPs
    std::unique_ptr<ComponentCarrierInfo> cc0(new ComponentCarrierInfo());
    std::unique_ptr<BandwidthPartInfo> bwp0(new BandwidthPartInfo());

    /*
     * CC band configuration n257F (NR Release 15): four contiguous CCs of
     * 400MHz at maximum. In this automated example, each CC contains a single
     * BWP occupying the whole CC bandwidth.
     *
     * The configured spectrum division is:
     * ---- Band -----
     * ------CC0------
     * ------BWP0-----
     *
     */

    const uint8_t numContiguousCcs = 1; // max 4 CCs per Band

    // Create the configuration for the CcBwpHelper
    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,
                                                   bandwidthBand,
                                                   numContiguousCcs,
                                                   BandwidthPartInfo::UMi_StreetCanyon_LoS);

    bandConf.m_numBwp = 1; // 1 BWP per CC

    // By using the configuration created, it is time to make the operation band
    // ìœ„ì— ì„¤ì •í•œëŒ€ë¡œ ìë™ìƒì„± ë„ìš°ë¯¸? ê°™ì€ ì—­í• 
    band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);

    // ìë™ìœ¼ë¡œ ThreeGppPropagationLossModel ì‚¬ìš©
    nrHelper->SetPathlossAttribute("ShadowingEnabled",
                                   BooleanValue(true)); // ì‹ í˜¸ ê°ì‡  í˜„ìƒ ON
    nrEpcHelper->SetAttribute("S1uLinkDelay", TimeValue(MilliSeconds(0)));
    // gnb<->core network ì „ì†¡ ì†ë„ 0ms
    nrHelper->SetSchedulerTypeId(TypeId::LookupByName("ns3::NrMacSchedulerTdmaRR"));
    // ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì •(round robinë°©ì‹ì„)

    // ë¹”í¬ë° ì„¤ì •
    idealBeamformingHelper->SetAttribute("BeamformingMethod",
                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));

    nrHelper->InitializeOperationBand(&band);
    // bnadë¥¼ nrì‹œìŠ¤í…œì— ì´ˆê¸°í™”í•¨ ì¦‰ ì´ ë°´ë“œ ì‚¬ìš©í•œë‹¤ëŠ” ëœ»
    allBwps = CcBwpCreator::GetAllBwps({band});
    // bandì•ˆì— ë“¤ì–´ìˆëŠ” ëª¨ë“  bwpì¶”ì¶œí•´ì„œ allbwpsì— ì €ì¥

    double totalTxPower = 8.0;             // ë‹¨ìœ„dBm
    double x = pow(10, totalTxPower / 10); // ì „ì†¡ ì „ë ¥ì„ watt ë‹¨ìœ„ë¡œ ë³€í™˜
    std::cout << "totalTxPower of 1gNB in W : " << x << std::endl;
    // totalTxPower = 30 dBm â†’ x = 1 W

    // Antennas for all the UEs
    nrHelper->SetUeAntennaAttribute("NumRows", UintegerValue(2));
    nrHelper->SetUeAntennaAttribute("NumColumns", UintegerValue(4));
    // 2*4 ì¦‰ 8ê°œ ì•ˆí…Œë‚˜
    nrHelper->SetUeAntennaAttribute("AntennaElement",
                                    PointerValue(CreateObject<IsotropicAntennaModel>()));
    // ë“±ë°©ì„± ì•ˆí…Œë‚˜ Isotropical ë¡œ MIMOêµ¬í˜„

    // Antennas for all the gNbs
    nrHelper->SetGnbAntennaAttribute("NumRows", UintegerValue(4));
    nrHelper->SetGnbAntennaAttribute("NumColumns", UintegerValue(8));
    nrHelper->SetGnbAntennaAttribute("AntennaElement",
                                     PointerValue(CreateObject<IsotropicAntennaModel>()));

    uint32_t bwpIdForVideo = 0;

    // ì„œë¹„ìŠ¤ íƒ€ì… -> BWP ë§¤í•‘ (QoS ì§€ì •), í•˜ë‚˜ì˜ BWPì— ì—¬ëŸ¬ê°œì˜ QoS ì§€ì • ê°€ëŠ¥ ë¹„ë””ì˜¤ë§Œ ì§€ì •

    nrHelper->SetGnbBwpManagerAlgorithmAttribute("NGBR_VIDEO_TCP_PREMIUM",
                                                 UintegerValue(bwpIdForVideo));

    // Install and get the pointers to the NetDevices
    NetDeviceContainer gnbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);
    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);

    // UEì— ëŒ€í•´ Phy ì½œë°± ì—°ê²°
    Ptr<NetDevice> dev = ueNodes.Get(0)->GetDevice(0);
    Ptr<NrUeNetDevice> ueDev = DynamicCast<NrUeNetDevice>(dev);
    if (ueDev)
    {
        // ì²« ë²ˆì§¸ CC(í˜¹ì€ ì›í•˜ëŠ” CC ì¸ë±ìŠ¤)
        Ptr<NrUePhy> phy = ueDev->GetPhy(0);
        phy->TraceConnectWithoutContext("ReportUeMeasurements", MakeCallback(&UeMeasCallback));
    }

    int64_t randomStream = 1; // ëœë¤ ì‹œë“œ ê³ ì • ì‹œë®¬ë ˆì´ì…˜ ëŒë ¤ë„ ê²°ê³¼ ê°™ê²Œ
    randomStream += nrHelper->AssignStreams(gnbNetDev, randomStream);
    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);

    std::string pattern =
        "F|F|F|F|F|F|F|F|F|F|"; // Pattern can be e.g. "DL|S|UL|UL|DL|DL|S|UL|UL|DL|"
    // FëŠ” flexible
    // D Downlink
    // U Uplink

    // 0ë²ˆì§¸ gnbì˜ 0ë²ˆì§¸ bwpì— ëŒ€í•œ ì„¤ì •
    // ì „ì²´ ì „ë ¥ì— ëŒ€í•œ ë¶€ë¶„ì„ 4ê°œë¡œ ë‚˜ëˆ„ì–´ 0.25ë¥¼ ê³±í•¨
    // get(0)ì€ ê¸°ì§€êµ­ => ê¸°ì§€êµ­ ì²«ë²ˆì¨°
    for (int i = 0; i < gNbNum; i++)
    {
        nrHelper->GetGnbPhy(gnbNetDev.Get(i), 0)
            ->SetAttribute("Numerology", UintegerValue(numerology));
        nrHelper->GetGnbPhy(gnbNetDev.Get(i), 0)
            ->SetAttribute("TxPower", DoubleValue(10 * log10(x * 0.25)));
        nrHelper->GetGnbPhy(gnbNetDev.Get(i), 0)->SetAttribute("Pattern", StringValue(pattern));
    }

    // ì„¤ì • ì ìš©
    for (auto it = gnbNetDev.Begin(); it != gnbNetDev.End(); ++it)
    {
        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();
        // gnbNetDevëŠ” gNBë””ë°”ì´ìŠ¤ë“¤ì˜ ì»¨í…Œì´ë„ˆ(NetDeviceContainer)í˜•ì‹ì„
        // ê° gNB ë””ë°”ì´ìŠ¤ë¥¼ NRGnbNetDeviceë¡œ íƒ€ì… ìºìŠ¤íŒ…í•´ì„œ updateconfigí˜¸ì¶œ
    }

    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)
    {
        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();
    }
    // ê¸°ì§€êµ­ì´ë‘ ë‹¨ë§ ì„¤ì • ë‹¤ í•˜ê³ 
    // 5GC, ì„¤ì •================================================================
    //  create the internet and install the IP stack on the UEs
    // get SGW/PGW and create a single RemoteHost
    Ptr<Node> pgw = nrEpcHelper->GetPgwNode(); // ì¸í„°ë„·ìœ¼ë¡œ ë‚˜ê°€ëŠ” ì¶œêµ¬ ì—­í• (EPCì—ì„œ PGWë¡œ ë³´ëƒ„)
    NodeContainer remoteHostContainer;         // ì›ê²© í˜¸ìŠ¤íŠ¸ë¥¼ ë‹´ì„ ì»¨í…Œì´ë„ˆ
    remoteHostContainer.Create(1);             // ì¸í„°ë„·ì— ì—°ê²°ëœ ì„œë²„ ë…¸íŠ¸  ìƒì„±
    Ptr<Node> remoteHost = remoteHostContainer.Get(0); // ìƒì„±í•œ ë…¸íŠ¸ í¬ì¸í„°ë¡œ êº¼ëƒ„
    InternetStackHelper internet;
    internet.Install(remoteHostContainer);
    internet.Install(pgw);
    // remoteHostì— TCP/IP ìŠ¤íƒ ì„¤ì¹˜ ì´ê±¸í•´ì•¼ ì¸í„°ë„·ì—ì„œ íŒ¨í‚· ì£¼ê³  ë°›ì„ ìˆ˜ ìˆìŒ

    // connect a remoteHost to pgw. Setup routing too
    PointToPointHelper p2ph;
    p2ph.SetDeviceAttribute("DataRate", DataRateValue(DataRate("100Gb/s")));
    p2ph.SetDeviceAttribute("Mtu", UintegerValue(2500));
    p2ph.SetChannelAttribute("Delay", TimeValue(Seconds(0.000)));
    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);
    // pgwì™€ remotehostì§ì ‘ ì—°ê²°(100Gbps ì†ë„, 0ì´ˆ ì§€ì—°, 2500 MTU(ìµœëŒ€ ì „ì†¡ íŒ¨í‚·))

    Ipv4AddressHelper ipv4h;
    Ipv4StaticRoutingHelper ipv4RoutingHelper;
    ipv4h.SetBase("1.0.0.0", "255.0.0.0");
    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);
    // PGW/remoteHostì— IP ì£¼ì†Œ ë¶€ì—¬(prefixëŠ” /8 (255.0.0.0))

    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =
        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());
    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address("7.0.0.0"), Ipv4Mask("255.0.0.0"), 1);
    // remotehostì— ì •ì  ë¼ìš°íŒ…
    // ëª©ì ì§€ê°€ 7.0.0.0/8ì¸ íŒ¨í‚·ì€ ì¸í„°í˜ì´ìŠ¤ 1 (â†’ PGW)ë¡œ ë³´ëƒ„
    // UEë“¤(ë³´í†µ 7.x.x.x IPë¥¼ ë°›ìŒ)ì—ê²Œ ë³´ë‚´ëŠ” íŒ¨í‚·ì„ PGWë¥¼ í†µí•´ ì „ë‹¬

    internet.Install(ueNodes);
    Ipv4InterfaceContainer ueIpIface;
    ueIpIface = nrEpcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));
    // ê° ueì— TCP/IP ìŠ¤íƒ ì„¤ì¹˜, EPCë¥¼ í†µí•´ ê° UEì£¼ì†Œ í• ë‹¹(ìœ„ì— ì •ì˜í•œëŒ€ë¡œ 7.0.0.Xí˜•íƒœ)
    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);
    // remotehost ipì£¼ì†Œ ì €ì¥ (ì„œë²„ ì ‘ì†ìš©ìœ¼ë¡œ ì‚¬ìš©)
    //[UE] ---(5G ë¬´ì„ )--> [gNB] --> [PGW] <--(P2P)-- [remoteHost]

    // Set the default gateway for the UEs
    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)
    {
        Ptr<Ipv4StaticRouting> ueStaticRouting =
            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());
        // UE ë…¸ë“œì˜ ë¼ìš°íŒ… í…Œì´ë¸”ì— ì ‘ê·¼
        ueStaticRouting->SetDefaultRoute(nrEpcHelper->GetUeDefaultGatewayAddress(), 1);
        // ê¸°ë³¸ ê²Œì´íŠ¸ì›¨ì´ ì£¼ì†Œ ì„¤ì •
    }
    // attach UEs to the closest gNB before creating the dedicated flows
    nrHelper->AttachToClosestEnb(ueNetDev, gnbNetDev);
    // ueë“¤ì„ ê°€ì¥ ê°€ê¹Œìš´ gnbì— ì—°ê²°í•¨(RRC, BWPë§¤í•‘, DRB ìƒì„±)

    // í•¸ë“œì˜¤ë²„ í™œì„±í™” handoverhandoverhandoverhandoverhandoverhandoverhandoverhandoverhandover
    // Handover related functions
    // void AddX2Interface(NodeContainer gnbNodes);
    // void AddX2Interface(Ptr<Node> gnbNode1, Ptr<Node> gnbNode2);

    // std::string GetHandoverAlgorithmType() const;
    // void SetHandoverAlgorithmType(std::string type);
    // void SetHandoverAlgorithmAttribute(std::string n, const AttributeValue& v);
    // void HandoverRequest(Time hoTime,
    //                      Ptr<NetDevice> ueDev,
    //                      Ptr<NetDevice> sourceGnbDev,
    //                      Ptr<NetDevice> targetGnbDev);
    // void HandoverRequest(Time hoTime,
    //                      Ptr<NetDevice> ueDev,
    //                      Ptr<NetDevice> sourceGnbDev,
    //                      uint16_t targetCellId);

    // nrHelper->HandoverRequest(Seconds(5), ueNetDev.Get(0), gnbNetDev.Get(0), gnbNetDev.Get(1));
    //  install UDP applications
    uint16_t numFlowsUe = 1; // UEë§ˆë‹¤ í•œê°œì˜ flow ìƒì„±
    uint16_t dlPort = 1234;
    uint16_t ulPort = dlPort + gNbNum * ueNum * numFlowsUe + 1;
    // dl ul í¬íŠ¸ í• ë‹¹

    ApplicationContainer clientApps;
    ApplicationContainer serverApps;

    bool disableDl = false;
    bool disableUl = false;
    uint32_t udpPacketSizeBe = 100;
    uint32_t lambdaUll = 2;

    uint16_t u = 0;
    if (!disableDl)
    { // ì´ê²Œ ë¬´ì¡°ê±´ ì²˜ìŒ ì„¤ì¹˜í•œ ì¸í„°í˜ì´ìŠ¤ë¡œ íŒ¨í‚·ì„ ë³´ëƒ„
        PacketSinkHelper dlPacketSinkHelper("ns3::UdpSocketFactory",
                                            InetSocketAddress(Ipv4Address::GetAny(), dlPort));
        // UEê°€ ìˆ˜ì‹ ìª½ì„ (ì§€ì •ëœ í¬íŠ¸ë¡œ ì˜¤ëŠ” ì–´ë–¤ ë°ì´í„°ë“ (GetAny) ë°›ì•„ì¤Œ)
        serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(u)));

        UdpClientHelper dlClient(ueIpIface.GetAddress(u),
                                 dlPort); // ëª©ì ì§€(UE IP), ëª©ì ì§€ í¬íŠ¸
        dlClient.SetAttribute("PacketSize",
                              UintegerValue(udpPacketSizeBe)); // íŒ¨í‚· í•˜ë‚˜ì˜ í¬ê¸°
        dlClient.SetAttribute("Interval",
                              TimeValue(Seconds(1.0 / lambdaUll))); // ì „ì†¡ ì£¼ê¸°(íŒ¨í‚· ì „ì†¡ë¥  ì œì–´)
        dlClient.SetAttribute("MaxPackets",
                              UintegerValue(0xFFFFFFFF)); // ì—„ì²­ë‚˜ê²Œ ë§ì€ íŒ¨í‚· 16ì§„ìˆ˜
        clientApps.Add(dlClient.Install(remoteHost));

        Ptr<EpcTft> tft = Create<EpcTft>(); // Traffic Flow Template(íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” íŒ¨í‚·ì„
                                            // ì–´ë–¤ Bearerì— ë§¤í•‘í• ì§€ ê²°ì •)
        EpcTft::PacketFilter dlpf;
        dlpf.localPortStart = dlPort;
        dlpf.localPortEnd = dlPort;
        ++dlPort; // ë‹¤ìŒ flowìœ„í•´ í¬íŠ¸ë²ˆí˜¸ ì¦ê°€ => ì¦‰ ê° flowë§ˆë‹¤ ë‹¤ë¥¸ í¬íŠ¸ ì‚¬ìš©ì¤‘
        tft->Add(dlpf);

        // QoSí´ë˜ìŠ¤(QCI) ê²°ì •
        enum EpsBearer::Qci q;

        q = EpsBearer::NGBR_VIDEO_TCP_PREMIUM;

        // EPS Bearer ìƒì„± + í™œì„±í™”
        EpsBearer bearer(q);
        nrHelper->ActivateDedicatedEpsBearer(ueNetDev.Get(u), bearer, tft);
    }

    if (!disableUl)
    {
        PacketSinkHelper ulPacketSinkHelper("ns3::UdpSocketFactory",
                                            InetSocketAddress(Ipv4Address::GetAny(), ulPort));
        serverApps.Add(ulPacketSinkHelper.Install(remoteHost));

        UdpClientHelper ulClient(remoteHostAddr, ulPort);
        ulClient.SetAttribute("PacketSize", UintegerValue(udpPacketSizeBe));
        ulClient.SetAttribute("Interval", TimeValue(Seconds(1.0 / lambdaUll)));
        ulClient.SetAttribute("MaxPackets", UintegerValue(0xFFFFFFFF));
        clientApps.Add(ulClient.Install(ueNodes.Get(u)));

        Ptr<EpcTft> tft = Create<EpcTft>();
        EpcTft::PacketFilter ulpf;
        ulpf.remotePortStart = ulPort;
        ulpf.remotePortEnd = ulPort;
        ++ulPort;
        tft->Add(ulpf);

        enum EpsBearer::Qci q;
        q = EpsBearer::NGBR_VIDEO_TCP_PREMIUM;

        EpsBearer bearer(q);
        nrHelper->ActivateDedicatedEpsBearer(ueNetDev.Get(u), bearer, tft);
    }

    double simTime = 10;          // seconds
    double udpAppStartTime = 0.4; // seconds

    // start UDP server and client apps
    serverApps.Start(Seconds(udpAppStartTime));
    clientApps.Start(Seconds(udpAppStartTime));
    serverApps.Stop(Seconds(simTime));
    clientApps.Stop(Seconds(simTime));

    // enable the traces provided by the nr module
    // nrHelper->EnableTraces();//nrëª¨ë“ˆì—ì„œ ì œê³µí•˜ëŠ” ë‚´ë¶€(PHY,MAX,RLC) íŠ¸ë ˆì´ìŠ¤

    FlowMonitorHelper flowmonHelper;
    NodeContainer endpointNodes;
    endpointNodes.Add(remoteHost);
    endpointNodes.Add(ueNodes);

    Ptr<ns3::FlowMonitor> monitor =
        flowmonHelper.Install(endpointNodes); // ê° ë…¸ë“œ ê°„ì˜ UDP flow ì¶”ì 
    // BinWidthëŠ” íˆìŠ¤í† ê·¸ë¨ í˜•íƒœë¡œ ë¶„í¬ ë‚˜íƒ€ë‚¼ ë•Œ ê°„ê²©ì„ ëª‡ ì´ˆ ë‹¨ìœ„ë¡œ ë‚˜ëˆŒì§€
    monitor->SetAttribute("DelayBinWidth", DoubleValue(0.001)); // ì§€ì—° ì¸¡ì • êµ¬ê°„(1ms)
    monitor->SetAttribute("JitterBinWidth",
                          DoubleValue(0.001)); // ì§€í„°(íŒ¨í‚· ê°„ ì „ì†¡ ê°„ê²©ì˜ ë³€í™”ëŸ‰) ì¸¡ì • êµ¬ê°„(1ms)
    // íŒ¨í‚·ì´ ê·œì¹™ì ìœ¼ë¡œ ì˜¤ì§€ ì•Šê³  ë„ì°©í•  ë•Œ ê·¸ ë¶ˆì•ˆì •ì„± ì¸¡ì •
    monitor->SetAttribute("PacketSizeBinWidth",
                          DoubleValue(20)); // íŒ¨í‚· í¬ê¸° íˆìŠ¤í† ê·¸ë¨ êµ¬ê°„(20ë°”ì´íŠ¸ ë‹¨ìœ„)
                                            // íŒ¨í‚·ì˜ í¬ê¸°ë¥¼ ëª‡ ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ë‚˜ëˆŒì§€

    Simulator::Stop(Seconds(simTime)); // ëª‡ì´ˆë’¤ì— ì‹œë®¬ ë©ˆì¶œì§€ ê²°ì •
    Simulator::Run();

    Simulator::Destroy();
    return 0;
}
//
// Created by ê³ ê¸°í˜¸ on 25. 6. 23.
//
