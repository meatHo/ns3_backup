

#include "ns3/antenna-module.h"
#include "ns3/applications-module.h"
#include "ns3/cc-bwp-helper.h"
#include "ns3/config-store-module.h"
#include "ns3/config-store.h"
#include "ns3/core-module.h"
#include "ns3/epc-tft.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/ideal-beamforming-algorithm.h"
#include "ns3/internet-apps-module.h"
#include "ns3/internet-module.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/log.h"
#include "ns3/mobility-helper.h"
#include "ns3/mobility-module.h"
#include "ns3/network-module.h"
#include "ns3/nr-helper.h"
#include "ns3/nr-mac-scheduler-tdma-rr.h"
#include "ns3/nr-module.h"
#include "ns3/nr-point-to-point-epc-helper.h"
#include "ns3/point-to-point-helper.h"
#include "ns3/point-to-point-module.h"

#include <cmath>
using namespace ns3;

void
UeMeasCallback(uint16_t rnti,
               uint16_t cellId,
               double rsrp,
               double rsrq,
               bool isServingCell,
               uint8_t componentCarrierId)
{
    std::cout << "📶 [Meas] RNTI=" << rnti << " CellId=" << cellId
              << (isServingCell ? " (S)" : " (N)") << "  RSRP=" << rsrp << " dBm,"
              << " RSRQ=" << rsrq << " dB\n";
}

int
main(int argc, char* argv[])
{
    // LogComponentEnable("NrUeRrc", LOG_LEVEL_FUNCTION);
    // LogComponentEnable("NrHelper", LOG_LEVEL_FUNCTION);
    // LogComponentEnable("NrUeRrc", LOG_LEVEL_FUNCTION);  // Check UE RRC behavior
    // LogComponentEnable("NrGnbRrc", LOG_LEVEL_FUNCTION); // Check gNB RRC behavior
    uint16_t gNbNum = 2;
    uint16_t ueNum = 1;

    // ands = 1;
    double centralFrequencyBand = 3.5e9;
    // double bandwidthBand = 3e9;//3기가 헤르즈
    double bandwidthBand = 1e8; // 100 MHz

    uint16_t numerology = 0;
    // SCS설정 0=15kHz 3=120kHz
    //---------------------------------------------------------------------------
    NodeContainer gNbNodes;
    NodeContainer ueNodes;

    double gNbHeight = 10;
    double ueHeight = 10;

    gNbNodes.Create(gNbNum);
    ueNodes.Create(ueNum);

    Ptr<ListPositionAllocator> apPositionAlloc =
        CreateObject<ListPositionAllocator>(); // gnb위치 저장
    Ptr<ListPositionAllocator> uePositionAlloc =
        CreateObject<ListPositionAllocator>(); // ue위치 저장

    // x y z meter단위
    //  gnb---------gnb
    //  ue ->->->->->
    apPositionAlloc->Add(Vector(0.0, 0.0, gNbHeight));
    apPositionAlloc->Add(Vector(10.0, 0.0, gNbHeight));
    uePositionAlloc->Add(Vector(0.0, 0.0, ueHeight));

    // 위치 설정
    MobilityHelper mobility;
    mobility.SetMobilityModel("ns3::ConstantVelocityMobilityModel");

    MobilityHelper mobility_gnb;
    mobility_gnb.SetMobilityModel("ns3::ConstantPositionMobilityModel");

    mobility_gnb.SetPositionAllocator(apPositionAlloc);
    mobility_gnb.Install(gNbNodes);

    mobility.SetPositionAllocator(uePositionAlloc);
    mobility.Install(ueNodes);
    // 여기 위는 초기 위를 설정
    // 밑에는 이동

    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)
    {
        Ptr<Node> node = ueNodes.Get(i);
        Ptr<ConstantVelocityMobilityModel> mobility =
            node->GetObject<ConstantVelocityMobilityModel>();
        mobility->SetVelocity(Vector(1.0, 0.0, 0.0)); // x축으로 1m/s
    }

    //==============================UE, gNB 위치 설정==================

    // setup the nr simulation
    Ptr<NrPointToPointEpcHelper> nrEpcHelper = CreateObject<NrPointToPointEpcHelper>();
    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();
    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();

    nrHelper->SetBeamformingHelper(idealBeamformingHelper);
    nrHelper->SetEpcHelper(nrEpcHelper);

    // Handover algorithm 인스턴스 생성 수동 방식
    // Ptr<NrA3RsrpHandoverAlgorithm> algo = CreateObject<NrA3RsrpHandoverAlgorithm>();
    // (원한다면 히스테리시스나 TTT 같은 속성 조정)
    // algo->SetAttribute("Hysteresis", DoubleValue(3.0));
    // algo->SetAttribute("TimeToTrigger", TimeValue(MilliSeconds(256)));

    // Or a more typical value like 3.0 dB if desired:
    // nrHelper->SetHandoverAlgorithmAttribute("A3Offset", DoubleValue(3.0));

    // bwp 설정, 부파수 분할, Component Carrier
    /*
     * Setup the configuration of the spectrum. There is a contiguous and a non-contiguous
     * example:
     * 1) One operation band is deployed with 4 contiguous component carriers
     *    (CC)s, which are automatically generated by the ccBwpManager
     * 2) One operation bands non-contiguous case. CCs and BWPs are manually created
     */
    // contiguous는 연속된 주파수 대역으로 자동구성할 때
    // non-contiguous는 수동으로 CC+BWP설정(cttc-nr-cc-bwp-demo.cc 참고)

    BandwidthPartInfoPtrVector allBwps;
    CcBwpCreator ccBwpCreator;

    OperationBandInfo band;

    // For the case of manual configuration of CCs and BWPs
    std::unique_ptr<ComponentCarrierInfo> cc0(new ComponentCarrierInfo());
    std::unique_ptr<BandwidthPartInfo> bwp0(new BandwidthPartInfo());

    /*
     * CC band configuration n257F (NR Release 15): four contiguous CCs of
     * 400MHz at maximum. In this automated example, each CC contains a single
     * BWP occupying the whole CC bandwidth.
     *
     * The configured spectrum division is:
     * ---- Band -----
     * ------CC0------
     * ------BWP0-----
     *
     */

    const uint8_t numContiguousCcs = 1; // max 4 CCs per Band

    // Create the configuration for the CcBwpHelper
    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,
                                                   bandwidthBand,
                                                   numContiguousCcs,
                                                   BandwidthPartInfo::UMi_StreetCanyon_LoS);

    bandConf.m_numBwp = 1; // 1 BWP per CC

    // By using the configuration created, it is time to make the operation band
    // 위에 설정한대로 자동생성 도우미? 같은 역할
    band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);

    // 자동으로 ThreeGppPropagationLossModel 사용
    nrHelper->SetPathlossAttribute("ShadowingEnabled",
                                   BooleanValue(true)); // 신호 감쇠 현상 ON
    nrEpcHelper->SetAttribute("S1uLinkDelay", TimeValue(MilliSeconds(0)));
    // gnb<->core network 전송 속도 0ms
    nrHelper->SetSchedulerTypeId(TypeId::LookupByName("ns3::NrMacSchedulerTdmaRR"));
    // 스케줄러 설정(round robin방식임)

    // 빔포밍 설정
    idealBeamformingHelper->SetAttribute("BeamformingMethod",
                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));

    nrHelper->InitializeOperationBand(&band);
    // bnad를 nr시스템에 초기화함 즉 이 밴드 사용한다는 뜻
    allBwps = CcBwpCreator::GetAllBwps({band});
    // band안에 들어있는 모든 bwp추출해서 allbwps에 저장

    double totalTxPower = 8.0;             // 단위dBm
    double x = pow(10, totalTxPower / 10); // 전송 전력을 watt 단위로 변환
    std::cout << "totalTxPower of 1gNB in W : " << x << std::endl;
    // totalTxPower = 30 dBm → x = 1 W

    // Antennas for all the UEs
    nrHelper->SetUeAntennaAttribute("NumRows", UintegerValue(2));
    nrHelper->SetUeAntennaAttribute("NumColumns", UintegerValue(4));
    // 2*4 즉 8개 안테나
    nrHelper->SetUeAntennaAttribute("AntennaElement",
                                    PointerValue(CreateObject<IsotropicAntennaModel>()));
    // 등방성 안테나 Isotropical 로 MIMO구현

    // Antennas for all the gNbs
    nrHelper->SetGnbAntennaAttribute("NumRows", UintegerValue(4));
    nrHelper->SetGnbAntennaAttribute("NumColumns", UintegerValue(8));
    nrHelper->SetGnbAntennaAttribute("AntennaElement",
                                     PointerValue(CreateObject<IsotropicAntennaModel>()));

    uint32_t bwpIdForVideo = 0;

    // 서비스 타입 -> BWP 매핑 (QoS 지정), 하나의 BWP에 여러개의 QoS 지정 가능 비디오만 지정

    nrHelper->SetGnbBwpManagerAlgorithmAttribute("NGBR_VIDEO_TCP_PREMIUM",
                                                 UintegerValue(bwpIdForVideo));

    // Install and get the pointers to the NetDevices
    NetDeviceContainer gnbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);
    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);

    // UE에 대해 Phy 콜백 연결
    Ptr<NetDevice> dev = ueNodes.Get(0)->GetDevice(0);
    Ptr<NrUeNetDevice> ueDev = DynamicCast<NrUeNetDevice>(dev);
    if (ueDev)
    {
        // 첫 번째 CC(혹은 원하는 CC 인덱스)
        Ptr<NrUePhy> phy = ueDev->GetPhy(0);
        phy->TraceConnectWithoutContext("ReportUeMeasurements", MakeCallback(&UeMeasCallback));
    }

    int64_t randomStream = 1; // 랜덤 시드 고정 시뮬레이션 돌려도 결과 같게
    randomStream += nrHelper->AssignStreams(gnbNetDev, randomStream);
    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);

    std::string pattern =
        "F|F|F|F|F|F|F|F|F|F|"; // Pattern can be e.g. "DL|S|UL|UL|DL|DL|S|UL|UL|DL|"
    // F는 flexible
    // D Downlink
    // U Uplink

    // 0번째 gnb의 0번째 bwp에 대한 설정
    // 전체 전력에 대한 부분을 4개로 나누어 0.25를 곱함
    // get(0)은 기지국 => 기지국 첫번쨰
    for (int i = 0; i < gNbNum; i++)
    {
        nrHelper->GetGnbPhy(gnbNetDev.Get(i), 0)
            ->SetAttribute("Numerology", UintegerValue(numerology));
        nrHelper->GetGnbPhy(gnbNetDev.Get(i), 0)
            ->SetAttribute("TxPower", DoubleValue(10 * log10(x * 0.25)));
        nrHelper->GetGnbPhy(gnbNetDev.Get(i), 0)->SetAttribute("Pattern", StringValue(pattern));
    }

    // 설정 적용
    for (auto it = gnbNetDev.Begin(); it != gnbNetDev.End(); ++it)
    {
        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();
        // gnbNetDev는 gNB디바이스들의 컨테이너(NetDeviceContainer)형식임
        // 각 gNB 디바이스를 NRGnbNetDevice로 타입 캐스팅해서 updateconfig호출
    }

    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)
    {
        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();
    }
    // 기지국이랑 단말 설정 다 하고
    // 5GC, 설정================================================================
    //  create the internet and install the IP stack on the UEs
    // get SGW/PGW and create a single RemoteHost
    Ptr<Node> pgw = nrEpcHelper->GetPgwNode(); // 인터넷으로 나가는 출구 역할(EPC에서 PGW로 보냄)
    NodeContainer remoteHostContainer;         // 원격 호스트를 담을 컨테이너
    remoteHostContainer.Create(1);             // 인터넷에 연결된 서버 노트  생성
    Ptr<Node> remoteHost = remoteHostContainer.Get(0); // 생성한 노트 포인터로 꺼냄
    InternetStackHelper internet;
    internet.Install(remoteHostContainer);
    internet.Install(pgw);
    // remoteHost에 TCP/IP 스택 설치 이걸해야 인터넷에서 패킷 주고 받을 수 있음

    // connect a remoteHost to pgw. Setup routing too
    PointToPointHelper p2ph;
    p2ph.SetDeviceAttribute("DataRate", DataRateValue(DataRate("100Gb/s")));
    p2ph.SetDeviceAttribute("Mtu", UintegerValue(2500));
    p2ph.SetChannelAttribute("Delay", TimeValue(Seconds(0.000)));
    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);
    // pgw와 remotehost직접 연결(100Gbps 속도, 0초 지연, 2500 MTU(최대 전송 패킷))

    Ipv4AddressHelper ipv4h;
    Ipv4StaticRoutingHelper ipv4RoutingHelper;
    ipv4h.SetBase("1.0.0.0", "255.0.0.0");
    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);
    // PGW/remoteHost에 IP 주소 부여(prefix는 /8 (255.0.0.0))

    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =
        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());
    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address("7.0.0.0"), Ipv4Mask("255.0.0.0"), 1);
    // remotehost에 정적 라우팅
    // 목적지가 7.0.0.0/8인 패킷은 인터페이스 1 (→ PGW)로 보냄
    // UE들(보통 7.x.x.x IP를 받음)에게 보내는 패킷을 PGW를 통해 전달

    internet.Install(ueNodes);
    Ipv4InterfaceContainer ueIpIface;
    ueIpIface = nrEpcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));
    // 각 ue에 TCP/IP 스택 설치, EPC를 통해 각 UE주소 할당(위에 정의한대로 7.0.0.X형태)
    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);
    // remotehost ip주소 저장 (서버 접속용으로 사용)
    //[UE] ---(5G 무선)--> [gNB] --> [PGW] <--(P2P)-- [remoteHost]

    // Set the default gateway for the UEs
    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)
    {
        Ptr<Ipv4StaticRouting> ueStaticRouting =
            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());
        // UE 노드의 라우팅 테이블에 접근
        ueStaticRouting->SetDefaultRoute(nrEpcHelper->GetUeDefaultGatewayAddress(), 1);
        // 기본 게이트웨이 주소 설정
    }
    // attach UEs to the closest gNB before creating the dedicated flows
    nrHelper->AttachToClosestEnb(ueNetDev, gnbNetDev);
    // ue들을 가장 가까운 gnb에 연결함(RRC, BWP매핑, DRB 생성)

    // 핸드오버 활성화 handoverhandoverhandoverhandoverhandoverhandoverhandoverhandoverhandover
    // Handover related functions
    // void AddX2Interface(NodeContainer gnbNodes);
    // void AddX2Interface(Ptr<Node> gnbNode1, Ptr<Node> gnbNode2);

    // std::string GetHandoverAlgorithmType() const;
    // void SetHandoverAlgorithmType(std::string type);
    // void SetHandoverAlgorithmAttribute(std::string n, const AttributeValue& v);
    // void HandoverRequest(Time hoTime,
    //                      Ptr<NetDevice> ueDev,
    //                      Ptr<NetDevice> sourceGnbDev,
    //                      Ptr<NetDevice> targetGnbDev);
    // void HandoverRequest(Time hoTime,
    //                      Ptr<NetDevice> ueDev,
    //                      Ptr<NetDevice> sourceGnbDev,
    //                      uint16_t targetCellId);

    // nrHelper->HandoverRequest(Seconds(5), ueNetDev.Get(0), gnbNetDev.Get(0), gnbNetDev.Get(1));
    //  install UDP applications
    uint16_t numFlowsUe = 1; // UE마다 한개의 flow 생성
    uint16_t dlPort = 1234;
    uint16_t ulPort = dlPort + gNbNum * ueNum * numFlowsUe + 1;
    // dl ul 포트 할당

    ApplicationContainer clientApps;
    ApplicationContainer serverApps;

    bool disableDl = false;
    bool disableUl = false;
    uint32_t udpPacketSizeBe = 100;
    uint32_t lambdaUll = 2;

    uint16_t u = 0;
    if (!disableDl)
    { // 이게 무조건 처음 설치한 인터페이스로 패킷을 보냄
        PacketSinkHelper dlPacketSinkHelper("ns3::UdpSocketFactory",
                                            InetSocketAddress(Ipv4Address::GetAny(), dlPort));
        // UE가 수신쪽임 (지정된 포트로 오는 어떤 데이터든(GetAny) 받아줌)
        serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(u)));

        UdpClientHelper dlClient(ueIpIface.GetAddress(u),
                                 dlPort); // 목적지(UE IP), 목적지 포트
        dlClient.SetAttribute("PacketSize",
                              UintegerValue(udpPacketSizeBe)); // 패킷 하나의 크기
        dlClient.SetAttribute("Interval",
                              TimeValue(Seconds(1.0 / lambdaUll))); // 전송 주기(패킷 전송률 제어)
        dlClient.SetAttribute("MaxPackets",
                              UintegerValue(0xFFFFFFFF)); // 엄청나게 많은 패킷 16진수
        clientApps.Add(dlClient.Install(remoteHost));

        Ptr<EpcTft> tft = Create<EpcTft>(); // Traffic Flow Template(특정 조건을 만족하는 패킷을
                                            // 어떤 Bearer에 매핑할지 결정)
        EpcTft::PacketFilter dlpf;
        dlpf.localPortStart = dlPort;
        dlpf.localPortEnd = dlPort;
        ++dlPort; // 다음 flow위해 포트번호 증가 => 즉 각 flow마다 다른 포트 사용중
        tft->Add(dlpf);

        // QoS클래스(QCI) 결정
        enum EpsBearer::Qci q;

        q = EpsBearer::NGBR_VIDEO_TCP_PREMIUM;

        // EPS Bearer 생성 + 활성화
        EpsBearer bearer(q);
        nrHelper->ActivateDedicatedEpsBearer(ueNetDev.Get(u), bearer, tft);
    }

    if (!disableUl)
    {
        PacketSinkHelper ulPacketSinkHelper("ns3::UdpSocketFactory",
                                            InetSocketAddress(Ipv4Address::GetAny(), ulPort));
        serverApps.Add(ulPacketSinkHelper.Install(remoteHost));

        UdpClientHelper ulClient(remoteHostAddr, ulPort);
        ulClient.SetAttribute("PacketSize", UintegerValue(udpPacketSizeBe));
        ulClient.SetAttribute("Interval", TimeValue(Seconds(1.0 / lambdaUll)));
        ulClient.SetAttribute("MaxPackets", UintegerValue(0xFFFFFFFF));
        clientApps.Add(ulClient.Install(ueNodes.Get(u)));

        Ptr<EpcTft> tft = Create<EpcTft>();
        EpcTft::PacketFilter ulpf;
        ulpf.remotePortStart = ulPort;
        ulpf.remotePortEnd = ulPort;
        ++ulPort;
        tft->Add(ulpf);

        enum EpsBearer::Qci q;
        q = EpsBearer::NGBR_VIDEO_TCP_PREMIUM;

        EpsBearer bearer(q);
        nrHelper->ActivateDedicatedEpsBearer(ueNetDev.Get(u), bearer, tft);
    }

    double simTime = 10;          // seconds
    double udpAppStartTime = 0.4; // seconds

    // start UDP server and client apps
    serverApps.Start(Seconds(udpAppStartTime));
    clientApps.Start(Seconds(udpAppStartTime));
    serverApps.Stop(Seconds(simTime));
    clientApps.Stop(Seconds(simTime));

    // enable the traces provided by the nr module
    // nrHelper->EnableTraces();//nr모듈에서 제공하는 내부(PHY,MAX,RLC) 트레이스

    FlowMonitorHelper flowmonHelper;
    NodeContainer endpointNodes;
    endpointNodes.Add(remoteHost);
    endpointNodes.Add(ueNodes);

    Ptr<ns3::FlowMonitor> monitor =
        flowmonHelper.Install(endpointNodes); // 각 노드 간의 UDP flow 추적
    // BinWidth는 히스토그램 형태로 분포 나타낼 때 간격을 몇 초 단위로 나눌지
    monitor->SetAttribute("DelayBinWidth", DoubleValue(0.001)); // 지연 측정 구간(1ms)
    monitor->SetAttribute("JitterBinWidth",
                          DoubleValue(0.001)); // 지터(패킷 간 전송 간격의 변화량) 측정 구간(1ms)
    // 패킷이 규칙적으로 오지 않고 도착할 때 그 불안정성 측정
    monitor->SetAttribute("PacketSizeBinWidth",
                          DoubleValue(20)); // 패킷 크기 히스토그램 구간(20바이트 단위)
                                            // 패킷의 크기를 몇 바이트 단위로 나눌지

    Simulator::Stop(Seconds(simTime)); // 몇초뒤에 시뮬 멈출지 결정
    Simulator::Run();

    Simulator::Destroy();
    return 0;
}
//
// Created by 고기호 on 25. 6. 23.
//
