/*
    KOH GIHO
    1gnb1rsu1ue_v1.cc
    GOAL : OBU detect two signals?

    RSU uses Sidelink
    gNb uses Uu
    OBU uses Sl && Uu

    0                     100
    gNb ---------------- RSU
    OBU ->

    ÏΩîÎìú ÏßÑÌñâ ÏàúÏÑú
    gnbÏÑ§Ï†ï -> rsuÏÑ§Ï†ï -> obuÏÑ§Ï†ï -> Ïù∏ÌÑ∞ÎÑ∑ ÏÑ§Ï†ï

    todo : Ìï†Í≤É
*/

#include "ns3/antenna-module.h"
#include "ns3/applications-module.h"
#include "ns3/config-store-module.h"
#include "ns3/config-store.h"
#include "ns3/core-module.h"
#include "ns3/epc-tft.h"
#include "ns3/flow-monitor-helper.h"
#include "ns3/internet-module.h"
#include "ns3/log.h"
#include "ns3/lte-module.h"
#include "ns3/mobility-module.h"
#include "ns3/network-module.h"
#include "ns3/nr-module.h"
#include "ns3/nr-sl-ue-cphy-sap.h"
#include "ns3/point-to-point-module.h"
#include "ns3/stats-module.h"
#include <ns3/pointer.h>

using namespace ns3;

void
UeMeasCallback(uint16_t cellId, uint16_t IMSI, uint16_t RNTI, double RSRP, uint8_t BWPId)
{
    std::cout << "üì∂ [Meas] cellId=" << cellId << " IMSI=" << IMSI << " BWPId=" << BWPId
              << "  RNTI=" << RNTI << " RSRP=" << RSRP << " dB\n";
}

void
LogUeFlowInfo (Ptr<Node> ue)
{
    Vector pos = ue->GetObject<MobilityModel> ()->GetPosition ();
    std::cout << "üïí " << Simulator::Now ().GetSeconds ()
              << "s | UE ÏúÑÏπò: (" << pos.x << ", " << pos.y << ")\n";

    // --- UU NetDevice (Ïù∏Îç±Ïä§ 0) ---
    Ptr<NrUeNetDevice> ueUuDev =
        ue->GetDevice (0)->GetObject<NrUeNetDevice> ();
    if (ueUuDev && ueUuDev->GetTargetEnb ())
    {
        std::cout << "üîó UU Ïó∞Í≤∞Îêú gNb ID: "
                  << ueUuDev->GetTargetEnb ()->GetCellId ()
                  << "  CELL ID: "
                  << ueUuDev->GetRrc ()->GetCellId ()
                  << "\n";
    }
    else
    {
        std::cout << "‚ö†Ô∏è UU ÏïÑÏßÅ gNBÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.\n";
    }

    // --- SL NetDevice (Ïù∏Îç±Ïä§ 1) ---
    Ptr<NrUeNetDevice> ueSlDev =
        ue->GetDevice (1)->GetObject<NrUeNetDevice> ();
    if (ueSlDev)
    {
        // 1) RRC ÏÉÅ SL Bearer Í∞úÏàò Ï°∞Ìöå
        // auto slBearerMap = ueSlDev->GetRrc ()->GetSlBearerMap ();
        // std::cout << "üîó SL Bearer Ïàò: " << slBearerMap.size () << "\n";

        // 2) PHY ÏÉÅÏúºÎ°úÎèÑ SL Í≥ÑÏ∏° Í∞ÄÎä•: ÏòàÎ•º Îì§Ïñ¥ ÌòÑÏû¨ Tx Ï†ÑÎ†•
        double txPwr = ueSlDev->GetPhy (0)->GetTxPower ();
        std::cout << "‚öôÔ∏è SL PHY TxPower = " << txPwr << " dBm\n";
    }
    else
    {
        std::cout << "‚ö†Ô∏è SL Ïû•ÏπòÍ∞Ä ÏóÜÏäµÎãàÎã§.\n";
    }

    // 1Ï¥à Îí§ Ïû¨Ìò∏Ï∂ú
    Simulator::Schedule (Seconds (1.0), &LogUeFlowInfo, ue);
}

int
main(void)
{
    Time simTime = Seconds(2);

    // Ìó¨Ìçº ÏÑ§Ï†ï
    // todo : pathlossÎ™®Îç∏ÏùÑ UuÏôÄ SLÎã§Î•¥Í≤å ÌïòÍ≥† Ïã∂ÏùÄÎç∞ Ïù¥Í≤å ÏïàÎê®..;;
    // Î™®Îç∏ÏùÑ Ïñ¥ÏºÄ ÏÑ§Ï†ïÌïòÎäîÏßÄÎèÑ Î™®Î•¥Í≤†Ïùå
    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();
    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();
    nrHelper->SetEpcHelper(epcHelper);

    nrHelper->SetPathlossAttribute("ShadowingEnabled", BooleanValue(true)); // Ïã†Ìò∏ Í∞êÏá† ÌòÑÏÉÅ ON
    epcHelper->SetAttribute("S1uLinkDelay", TimeValue(MilliSeconds(0)));
    // gnb<->core network Ï†ÑÏÜ° ÏÜçÎèÑ 0ms
    nrHelper->SetSchedulerTypeId(TypeId::LookupByName("ns3::NrMacSchedulerTdmaRR"));

    // gNb, Uu Í∏∞Î≥∏ ÏÑ§Ï†ï=======================================================
    uint16_t gNbNum = 1;
    double gNbFrequencyBand = 3.5e9; // 3.5GHz
    double gNbBandwidthBand = 1e8;   // 100MHz
    uint8_t gNbnumContiguousCc = 1;  // 100MHz ÏïàÏóê Î™áÍ∞úÏùò CCÍ∞Ä Îì§Ïñ¥Í∞Ä ÏûàÎäîÏßÄ
    uint16_t gNbNumerology = 0;
    double gNbTxPower = 8.0;                // Îã®ÏúÑdBm
    double gNbx = pow(10, gNbTxPower / 10); // to mW

    NodeContainer gNbNode;
    gNbNode.Create(gNbNum);

    // gNb, Uu Ï†ïÏ†Å ÏúÑÏπò ÏÑ§Ï†ï
    Ptr<ListPositionAllocator> gNbPositionAlloc = CreateObject<ListPositionAllocator>();
    gNbPositionAlloc->Add(Vector(0.0, 1.0, 0.0));

    MobilityHelper gNbMobility;
    gNbMobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
    gNbMobility.SetPositionAllocator(gNbPositionAlloc);
    gNbMobility.Install(gNbNode);

    // gNb band ÏÑ§Ï†ï
    CcBwpCreator gNbCcBwpCreators;
    OperationBandInfo gNbBand;

    CcBwpCreator::SimpleOperationBandConf gNbBandConf(
        gNbFrequencyBand,
        gNbBandwidthBand,
        gNbnumContiguousCc,
        BandwidthPartInfo::UMi_StreetCanyon_LoS); // Í≥†ÏÜçÎèÑÎ°ú ÏãúÎÇòÎ¶¨Ïò§ ÏÑ§Ï†ï
    gNbBandConf.m_numBwp = 1;                     // 1 BWP per CC
    gNbBand = gNbCcBwpCreators.CreateOperationBandContiguousCc(gNbBandConf);

    nrHelper->InitializeOperationBand(&gNbBand);
    BandwidthPartInfoPtrVector gNbBwp;
    gNbBwp = CcBwpCreator::GetAllBwps({gNbBand});

    NetDeviceContainer gnbNetDev = nrHelper->InstallGnbDevice(gNbNode, gNbBwp);

    // ÎπîÌè¨Î∞ç ÏÑ§Ï†ï
    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();
    nrHelper->SetBeamformingHelper(idealBeamformingHelper);
    idealBeamformingHelper->SetAttribute("BeamformingMethod",
                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));

    // ÏïàÌÖåÎÇò ÏÑ§Ï†ï
    nrHelper->SetGnbAntennaAttribute("NumRows", UintegerValue(4));
    nrHelper->SetGnbAntennaAttribute("NumColumns", UintegerValue(8));
    nrHelper->SetGnbAntennaAttribute("AntennaElement",
                                     PointerValue(CreateObject<IsotropicAntennaModel>()));
    nrHelper->SetGnbBwpManagerAlgorithmAttribute("NGBR_VIDEO_TCP_PREMIUM",
                                                 UintegerValue(0)); // bwpÌïòÎÇòÎßå ÌïúÍ±∞

    std::string pattern = "F|F|F|F|F|F|F|F|F|F|";
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)
        ->SetAttribute("Numerology", UintegerValue(gNbNumerology));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)
        ->SetAttribute("TxPower", DoubleValue(10 * log10(gNbx)));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)->SetAttribute("Pattern", StringValue(pattern));

    // ÏÑ§Ï†ï Ï†ÅÏö©
    for (auto it = gnbNetDev.Begin(); it != gnbNetDev.End(); ++it)
    {
        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();
    }

    // RSU, SL Í∏∞Î≥∏ ÏÑ§Ï†ï=======================================================
    uint16_t RsuNum = 1;
    double RsuFrequencyBand = 5.89e9;
    uint16_t RsuBandwidthBand = 400;
    uint8_t RsunumContiguousCc = 1;
    uint16_t RsuNumerology = 0;
    double RsuTxPower = 23.0; // Îã®ÏúÑdBm
    // double Rsux = pow(10, RsuTxPower / 10); // to mWdddd

    NodeContainer rsuNode;
    rsuNode.Create(RsuNum);

    Ptr<NrSlHelper> nrSlHelper = CreateObject<NrSlHelper>();
    nrSlHelper->SetEpcHelper(epcHelper);

    // Rsu Ï†ïÏ†Å ÏúÑÏπò ÏÑ§Ï†ï
    Ptr<ListPositionAllocator> RsuPositionAlloc = CreateObject<ListPositionAllocator>();
    RsuPositionAlloc->Add(Vector(100.0, 0.0, 0.0));

    MobilityHelper RsuMobility;
    RsuMobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
    RsuMobility.SetPositionAllocator(RsuPositionAlloc);
    RsuMobility.Install(rsuNode);

    // RSU band ÏÑ§Ï†ï
    CcBwpCreator RsuCcBwpCreator;
    CcBwpCreator::SimpleOperationBandConf RsuBandConf(RsuFrequencyBand,
                                                      RsuBandwidthBand,
                                                      RsunumContiguousCc,
                                                      BandwidthPartInfo::V2V_Highway);
    OperationBandInfo RsuBand = RsuCcBwpCreator.CreateOperationBandContiguousCc(RsuBandConf);

    nrHelper->InitializeOperationBand(&RsuBand);
    BandwidthPartInfoPtrVector RsuBwp = CcBwpCreator::GetAllBwps({RsuBand});

    // todo : path lossÎ™®Îç∏ ÏÑ§Ï†ï

    // RSU ÏïàÌÖåÎÇò ÏÑ§Ï†ï
    nrHelper->SetUeAntennaAttribute("NumRows", UintegerValue(1));
    nrHelper->SetUeAntennaAttribute("NumColumns", UintegerValue(2));
    nrHelper->SetUeAntennaAttribute("AntennaElement",
                                    PointerValue(CreateObject<IsotropicAntennaModel>()));

    nrHelper->SetUePhyAttribute("TxPower", DoubleValue(RsuTxPower)); // dBmÍ∑∏ÎåÄÎ°ú ÎÑ£ÎäîÎìØ

    nrHelper->SetUeMacTypeId(NrSlUeMac::GetTypeId()); // Ïù¥Í±∞ ÌïÑÏàòÏûÑ Ïù¥Ïú†Îäî Ï∞æÏïÑÎ¥ê todo
    nrHelper->SetUeMacAttribute("EnableSensing", BooleanValue(false));
    nrHelper->SetUeMacAttribute("T1", UintegerValue(2));
    nrHelper->SetUeMacAttribute("T2", UintegerValue(33));
    nrHelper->SetUeMacAttribute("ActivePoolId", UintegerValue(0));

    // todo : bwpÏÑ§Ï†ï. Ïó¨Í∏∞ Î∂ÄÎ∂ÑÏùÄ Íµ¨ÌòÑÏù¥ ÏïàÎêúÎìØ Ï£ºÏÑù Î≥¥Î©¥Îê®.
    uint8_t bwpIdForGbrMcptt = 0;
    nrHelper->SetBwpManagerTypeId(TypeId::LookupByName("ns3::NrSlBwpManagerUe"));
    // following parameter has no impact at the moment because:
    // 1. No support for PQI based mapping between the application and the LCs
    // 2. No scheduler to consider PQI
    // However, till such time all the NR SL examples should use GBR_MC_PUSH_TO_TALK
    // because we hard coded the PQI 65 in UE RRC.
    nrHelper->SetUeBwpManagerAlgorithmAttribute("GBR_MC_PUSH_TO_TALK",
                                                UintegerValue(bwpIdForGbrMcptt));

    std::set<uint8_t> bwpIdContainer;
    bwpIdContainer.insert(bwpIdForGbrMcptt);

    NetDeviceContainer RsuNetDev = nrHelper->InstallUeDevice(rsuNode, RsuBwp);

    // ÏÑ§Ï†ï Ï†ÅÏö©
    for (auto it = RsuNetDev.Begin(); it != RsuNetDev.End(); ++it)
    {
        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();
        // Update the RRC config.Must be called only once.
    }

    //  SideLink ÏÑ§Ï†ï===============================================================
    // Ïä§ÏºÄÏ•¥Îü¨ ÏÑ§Ï†ï

    nrSlHelper->SetNrSlSchedulerTypeId(NrSlUeMacSchedulerFixedMcs::GetTypeId());

    nrSlHelper->SetUeSlSchedulerAttribute("Mcs", UintegerValue(14));

    nrSlHelper->PrepareUeForSidelink(RsuNetDev, bwpIdContainer);

    // PrepareSingleUeForSidelinkÏãúÎ∞ú Ïó¨Í∏∞ÏÑú ÏóêÎü¨ÎÇ®

    //  SlResourcePoolNr IE
    LteRrcSap::SlResourcePoolNr slResourcePoolNr;
    // get it from pool factory
    Ptr<NrSlCommResourcePoolFactory> ptrFactory = Create<NrSlCommResourcePoolFactory>();
    std::vector<std::bitset<1>> slBitmap =
        {1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1}; // The sidelink time resource bitmap

    ptrFactory->SetSlTimeResources(slBitmap);
    ptrFactory->SetSlSensingWindow(100);    //!< Start of the sensing window in milliseconds.
    ptrFactory->SetSlSelectionWindow(5);    //!< End of the selection window in number of slots.
    ptrFactory->SetSlFreqResourcePscch(10); // PSCCH RBs
    ptrFactory->SetSlSubchannelSize(50);
    ptrFactory->SetSlMaxNumPerReserve(3);
    std::list<uint16_t> resourceReservePeriodList = {0, 100}; // in ms
    ptrFactory->SetSlResourceReservePeriodList(resourceReservePeriodList);

    LteRrcSap::SlResourcePoolNr pool = ptrFactory->CreatePool();
    slResourcePoolNr = pool;

    // Configure the SlResourcePoolConfigNr IE, which hold a pool and its id
    LteRrcSap::SlResourcePoolConfigNr slresoPoolConfigNr;
    slresoPoolConfigNr.haveSlResourcePoolConfigNr = true;
    // Pool id, ranges from 0 to 15
    uint16_t poolId = 0;
    LteRrcSap::SlResourcePoolIdNr slResourcePoolIdNr;
    slResourcePoolIdNr.id = poolId;
    slresoPoolConfigNr.slResourcePoolId = slResourcePoolIdNr;
    slresoPoolConfigNr.slResourcePool = slResourcePoolNr;

    // Configure the SlBwpPoolConfigCommonNr IE, which hold an array of pools
    LteRrcSap::SlBwpPoolConfigCommonNr slBwpPoolConfigCommonNr;
    // Array for pools, we insert the pool in the array as per its poolId
    slBwpPoolConfigCommonNr.slTxPoolSelectedNormal[slResourcePoolIdNr.id] = slresoPoolConfigNr;
    // ÌíÄÏùÑ Ïó¨Îü¨Í∞ú Ïì∏ Ïàò ÏûàÏßÄÎßå Ïö∞Î¶¨Îäî ÏòÅÏÉÅ Îç∞Ïù¥ÌÑ∞Î•º Ï†ÑÏÜ°ÌïòÎäî Í±∞ÎãàÍπå ÌíÄ ÌïòÎÇòÎßå Ïì∞ÎäîÍ≤å ÎßûÏùÑ ÎìØ

    // Configure the BWP IE
    LteRrcSap::Bwp bwp;
    bwp.numerology = RsuNumerology;
    bwp.symbolsPerSlots = 14; // ofdm symbol
    bwp.rbPerRbg = 1;         // Resource block per resource block group
    bwp.bandwidth = RsuBandwidthBand;

    // Configure the SlBwpGeneric IE
    LteRrcSap::SlBwpGeneric slBwpGeneric;
    slBwpGeneric.bwp = bwp;
    slBwpGeneric.slLengthSymbols = LteRrcSap::GetSlLengthSymbolsEnum(14);
    slBwpGeneric.slStartSymbol = LteRrcSap::GetSlStartSymbolEnum(0);

    // Configure the SlBwpConfigCommonNr IE
    LteRrcSap::SlBwpConfigCommonNr slBwpConfigCommonNr;
    slBwpConfigCommonNr.haveSlBwpGeneric = true;
    slBwpConfigCommonNr.slBwpGeneric = slBwpGeneric;
    slBwpConfigCommonNr.haveSlBwpPoolConfigCommonNr = true;
    slBwpConfigCommonNr.slBwpPoolConfigCommonNr = slBwpPoolConfigCommonNr;

    // Configure the SlFreqConfigCommonNr IE, which hold the array to store
    // the configuration of all Sidelink BWP (s).
    LteRrcSap::SlFreqConfigCommonNr slFreConfigCommonNr;
    // Array for BWPs. Here we will iterate over the BWPs, which
    // we want to use for SL.
    for (const auto& it : bwpIdContainer)
    {
        // it is the BWP id
        slFreConfigCommonNr.slBwpList[it] = slBwpConfigCommonNr;
    }

    // Configure the TddUlDlConfigCommon IE
    LteRrcSap::TddUlDlConfigCommon tddUlDlConfigCommon;
    tddUlDlConfigCommon.tddPattern = "DL|DL|DL|F|UL|UL|UL|UL|UL|UL|";

    // Configure the SlPreconfigGeneralNr IE
    LteRrcSap::SlPreconfigGeneralNr slPreconfigGeneralNr;
    slPreconfigGeneralNr.slTddConfig = tddUlDlConfigCommon;

    // Configure the SlUeSelectedConfig IE
    LteRrcSap::SlUeSelectedConfig slUeSelectedPreConfig;
    slUeSelectedPreConfig.slProbResourceKeep = 0;
    // Configure the SlPsschTxParameters IE
    LteRrcSap::SlPsschTxParameters psschParams;
    psschParams.slMaxTxTransNumPssch = 5;
    // Configure the SlPsschTxConfigList IE
    LteRrcSap::SlPsschTxConfigList pscchTxConfigList;
    pscchTxConfigList.slPsschTxParameters[0] = psschParams;
    slUeSelectedPreConfig.slPsschTxConfigList = pscchTxConfigList;

    /*
     * Finally, configure the SidelinkPreconfigNr This is the main structure
     * that needs to be communicated to NrSlUeRrc class
     */
    LteRrcSap::SidelinkPreconfigNr slPreConfigNr;
    slPreConfigNr.slPreconfigGeneral = slPreconfigGeneralNr;
    slPreConfigNr.slUeSelectedPreConfig = slUeSelectedPreConfig;
    slPreConfigNr.slPreconfigFreqInfoList[0] = slFreConfigCommonNr;

    // Communicate the above pre-configuration to the NrSlHelper
    nrSlHelper->InstallNrSlPreConfiguration(RsuNetDev, slPreConfigNr);

    // OBU Í∏∞Î≥∏ ÏÑ§Ï†ï===============================================================
    // obu Ïù∏Ïä§ÌÜ® Ìï†Îïå nrSlHelper->InstallNrSlPreConfiguration(obunetdev, slPreConfigNr);
    // ÌïòÎ©¥ Îê†ÎìØ
    NodeContainer ueNode;
    uint16_t ueNum = 1;
    ueNode.Create(ueNum);
    double ueTxPower = 3.0;

    Ptr<ListPositionAllocator> uePositionAlloc =
        CreateObject<ListPositionAllocator>(); // ueÏúÑÏπò Ï†ÄÏû•
    uePositionAlloc->Add(Vector(00.0, 0.0, 0.0));

    // ueÏù¥ÎèôÏÑ± ÏÑ§Ï†ï
    MobilityHelper ueMobility;
    ueMobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");

    ueMobility.SetPositionAllocator(uePositionAlloc);
    ueMobility.Install(ueNode);

    // obu UuÏó∞Í≤∞ ÏÑ§Ï†ï===============================================================
    nrHelper->SetUeMacTypeId(NrUeMac::GetTypeId()); // SL MACÏóêÏÑú ÏùºÎ∞ò MACÏúºÎ°ú Î≥ÄÍ≤Ω

    nrHelper->SetUeAntennaAttribute("NumRows", UintegerValue(2));
    nrHelper->SetUeAntennaAttribute("NumColumns", UintegerValue(4));
    // 2*4 Ï¶â 8Í∞ú ÏïàÌÖåÎÇò
    nrHelper->SetUeAntennaAttribute("AntennaElement",
                                    PointerValue(CreateObject<IsotropicAntennaModel>()));
    nrHelper->SetUePhyAttribute("TxPower", DoubleValue(ueTxPower)); // dBmÍ∑∏ÎåÄÎ°ú ÎÑ£ÎäîÎìØ

    // NetDeviceContainer ueUuNetDev = nrHelper->InstallUeDevice(ueNode, gNbBwp);

    std::vector<ObjectFactory> macUuFactory;
    ObjectFactory uufactory;
    uufactory.SetTypeId(NrUeMac::GetTypeId());
    macUuFactory.push_back(uufactory);

    NetDeviceContainer ueUuNetDev = nrHelper->InstallUeDevice(ueNode, gNbBwp, macUuFactory);

    DynamicCast<NrUeNetDevice>(ueUuNetDev.Get(0))->UpdateConfig();

    //========================================Set Uu settings same as the gnb
    // attachÏïàÌïòÎ†§Î©¥ Ï†ÄÍ±∞ Î∞ëÏóêÎ°ú ÏÑ§Ï†ïÌï¥ÏïºÌï®

    // Ptr<NrUeNetDevice> ueUusettingNetDev = ueUuNetDev.Get(0)->GetObject<NrUeNetDevice>();
    // Ptr<NrGnbNetDevice> gnbUusettingNetDev = gnbNetDev.Get(0)->GetObject<NrGnbNetDevice>();
    // for (uint32_t i = 0; i < gnbUusettingNetDev->GetCcMapSize(); ++i)
    // {
    //     ueUusettingNetDev->GetPhy(0)->SetDlAmc(
    //         DynamicCast<NrMacSchedulerNs3>(gnbUusettingNetDev->GetScheduler(i))->GetDlAmc());
    //     ueUusettingNetDev->GetPhy(i)->SetDlCtrlSyms(gnbUusettingNetDev->GetMac(i)->GetDlCtrlSyms());
    //     ueUusettingNetDev->GetPhy(i)->SetUlCtrlSyms(gnbUusettingNetDev->GetMac(i)->GetUlCtrlSyms());
    //     ueUusettingNetDev->GetPhy(i)->SetNumRbPerRbg(
    //         gnbUusettingNetDev->GetMac(i)->GetNumRbPerRbg());
    //     ueUusettingNetDev->GetPhy(i)->SetRbOverhead(gnbUusettingNetDev->GetPhy(i)->GetRbOverhead());
    //     ueUusettingNetDev->GetPhy(i)->SetSymbolsPerSlot(
    //         gnbUusettingNetDev->GetPhy(i)->GetSymbolsPerSlot());
    //     ueUusettingNetDev->GetPhy(i)->SetNumerology(gnbUusettingNetDev->GetPhy(i)->GetNumerology());
    //     ueUusettingNetDev->GetPhy(i)->SetPattern(gnbUusettingNetDev->GetPhy(i)->GetPattern());
    // }

    // obu SlÏó∞Í≤∞ ÏÑ§Ï†ï===============================================================

    nrHelper->SetUeAntennaAttribute("NumRows", UintegerValue(1));
    nrHelper->SetUeAntennaAttribute("NumColumns", UintegerValue(2));
    nrHelper->SetUeAntennaAttribute("AntennaElement",
                                    PointerValue(CreateObject<IsotropicAntennaModel>()));

    nrHelper->SetUePhyAttribute("TxPower", DoubleValue(10.0)); // dBmÍ∑∏ÎåÄÎ°ú ÎÑ£ÎäîÎìØ

    nrHelper->SetUeMacTypeId(NrSlUeMac::GetTypeId()); // Ïù¥Í±∞ ÌïÑÏàòÏûÑ Ïù¥Ïú†Îäî Ï∞æÏïÑÎ¥ê todo
    nrHelper->SetUeMacAttribute("EnableSensing", BooleanValue(false));
    nrHelper->SetUeMacAttribute("T1", UintegerValue(2));
    nrHelper->SetUeMacAttribute("T2", UintegerValue(33));
    nrHelper->SetUeMacAttribute("ActivePoolId", UintegerValue(0));

    std::vector<ObjectFactory> macSlFactory;
    ObjectFactory slfactory;
    slfactory.SetTypeId(NrSlUeMac::GetTypeId());
    macSlFactory.push_back(slfactory);

    NetDeviceContainer ueSlNetDev = nrHelper->InstallUeDevice(ueNode, RsuBwp, macSlFactory);
    DynamicCast<NrUeNetDevice>(ueSlNetDev.Get(0))->UpdateConfig();

    nrSlHelper->PrepareUeForSidelink(ueSlNetDev, bwpIdContainer);
    nrSlHelper->InstallNrSlPreConfiguration(ueSlNetDev, slPreConfigNr);

    // Uu PHYÏóêÏÑú RSRP Ï∏°Ï†ï ÏΩúÎ∞± Ïó∞Í≤∞ (gNbÏôÄÏùò Uu ÌÜµÏã†)
    Ptr<NrUeNetDevice> ueUuDev = DynamicCast<NrUeNetDevice>(ueUuNetDev.Get(0));
    // Get the first PHY (BWP) from the Uu NetDevice
    Ptr<NrUePhy> ueUuPhy = ueUuDev->GetPhy(0);
    ueUuPhy->TraceConnectWithoutContext("ReportRsrp", MakeCallback(&UeMeasCallback));





    // ueUuPhy->TraceConnectWithoutContext("ReportUeSlRsrpMeasurements",MakeCallback(&UeMeasCallback));
    // todo : Ïù¥Í±∞ Ïôú ÎèôÏûë ÏïàÌïòÎÉê ReportUeSlRsrpMeasurements nr-ue-phyÏóê ÏûàÏùå

    // Ïù∏ÌÑ∞ÎÑ∑ ÏÑ§Ï†ï===============================================================

    // Ïù∏ÌÑ∞ÎÑ∑ ÏÑ§Ïπò(gNb, RSU)================================================ÌîÑÎ°úÌÜ†ÏΩú ÏÑ§Ï†ï

    // ÏÑúÎ≤Ñ ÏÑ§Ïπò===============================================================
    // todo : Ìïú ÎÖ∏Îìú ÎßåÎì§Ïñ¥ÏÑú gnbÏôÄ rsu Ïó∞Í≤∞ÌïòÍ≥† Ïù∏ÌÑ∞ÎÑ∑ Ïä§ÌÖç ÏÑ§ÏπòÌõÑ Ìå®ÌÇ∑ Ï†ÑÏÜ° ÎêòÎÇò ÌôïÏù∏

    // gNb, RSUÏôÄ ÏÑúÎ≤Ñ Ïó∞Í≤∞=====================================================

    // Îç∞Ïù¥ÌÑ∞ ÌÜµÏã†==============================================================

    // ÌÖåÏä§Ìä∏Ïö© ÏΩîÎìú Ïó¨ Î∞ëÏóê Îã§ ÏßÄÏõåÎèÑ Îê®
    Ptr<Node> pgw = epcHelper->GetPgwNode(); // Ïù∏ÌÑ∞ÎÑ∑ÏúºÎ°ú ÎÇòÍ∞ÄÎäî Ï∂úÍµ¨ Ïó≠Ìï†(EPCÏóêÏÑú PGWÎ°ú Î≥¥ÎÉÑ)
    NodeContainer remoteHostContainer;       // ÏõêÍ≤© Ìò∏Ïä§Ìä∏Î•º Îã¥ÏùÑ Ïª®ÌÖåÏù¥ÎÑà
    remoteHostContainer.Create(1);           // Ïù∏ÌÑ∞ÎÑ∑Ïóê Ïó∞Í≤∞Îêú ÏÑúÎ≤Ñ ÎÖ∏Îìú  ÏÉùÏÑ±
    Ptr<Node> remoteHost = remoteHostContainer.Get(0); // ÏÉùÏÑ±Ìïú ÎÖ∏Îìú Ìè¨Ïù∏ÌÑ∞Î°ú Í∫ºÎÉÑ
    InternetStackHelper internet;
    internet.Install(remoteHostContainer);
    internet.Install(pgw);
    // remoteHostÏóê TCP/IP Ïä§ÌÉù ÏÑ§Ïπò Ïù¥Í±∏Ìï¥Ïïº Ïù∏ÌÑ∞ÎÑ∑ÏóêÏÑú Ìå®ÌÇ∑ Ï£ºÍ≥† Î∞õÏùÑ Ïàò ÏûàÏùå

    // connect a remoteHost to pgw. Setup routing too
    PointToPointHelper p2ph;
    p2ph.SetDeviceAttribute("DataRate", DataRateValue(DataRate("100Gb/s")));
    p2ph.SetDeviceAttribute("Mtu", UintegerValue(2500));
    p2ph.SetChannelAttribute("Delay", TimeValue(Seconds(0.000)));
    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);
    // pgwÏôÄ remotehostÏßÅÏ†ë Ïó∞Í≤∞(100Gbps ÏÜçÎèÑ, 0Ï¥à ÏßÄÏó∞, 2500 MTU(ÏµúÎåÄ Ï†ÑÏÜ° Ìå®ÌÇ∑))

    Ipv4AddressHelper ipv4h;
    Ipv4StaticRoutingHelper ipv4RoutingHelper;
    ipv4h.SetBase("1.0.0.0", "255.0.0.0");
    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);
    // PGW/remoteHostÏóê IP Ï£ºÏÜå Î∂ÄÏó¨(prefixÎäî /8 (255.0.0.0))

    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =
        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());
    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address("7.0.0.0"), Ipv4Mask("255.0.0.0"), 1);
    // remotehostÏóê Ï†ïÏ†Å ÎùºÏö∞ÌåÖ
    // Î™©Ï†ÅÏßÄÍ∞Ä 7.0.0.0/8Ïù∏ Ìå®ÌÇ∑ÏùÄ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ 1 (‚Üí PGW)Î°ú Î≥¥ÎÉÑ
    // UEÎì§(Î≥¥ÌÜµ 7.x.x.x IPÎ•º Î∞õÏùå)ÏóêÍ≤å Î≥¥ÎÇ¥Îäî Ìå®ÌÇ∑ÏùÑ PGWÎ•º ÌÜµÌï¥ Ï†ÑÎã¨

    internet.Install(ueNode);
    Ipv4InterfaceContainer ueUUIpIface;

    // OBUÏóêÏÑú UUÏä§ÌÉùÏóêÏÑú ipÏÑ§Ïπò todo: Ïó¨Í∏∞ Î∞ëÏùÄ ÏßÄÏö∞Î©¥ ÏïàÎê®!!!!!!!!!!!
    ueUUIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueUuNetDev));
    // Í∞Å ueÏóê TCP/IP Ïä§ÌÉù ÏÑ§Ïπò, EPCÎ•º ÌÜµÌï¥ Í∞Å UEÏ£ºÏÜå Ìï†Îãπ(ÏúÑÏóê Ï†ïÏùòÌïúÎåÄÎ°ú 7.0.0.XÌòïÌÉú)
    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);
    // remotehost ipÏ£ºÏÜå Ï†ÄÏû• (ÏÑúÎ≤Ñ Ï†ëÏÜçÏö©ÏúºÎ°ú ÏÇ¨Ïö©)
    //[UE] ---(5G Î¨¥ÏÑ†)--> [gNB] --> [PGW] <--(P2P)-- [remoteHost]

    // Set the default gateway for the UEs
    Ptr<Ipv4StaticRouting> ueStaticRouting =
        ipv4RoutingHelper.GetStaticRouting(ueNode.Get(0)->GetObject<Ipv4>());
    // UE ÎÖ∏ÎìúÏùò ÎùºÏö∞ÌåÖ ÌÖåÏù¥Î∏îÏóê Ï†ëÍ∑º
    ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);

    // Í∏∞Î≥∏ Í≤åÏù¥Ìä∏Ïõ®Ïù¥ Ï£ºÏÜå ÏÑ§Ï†ï
    uint16_t numFlowsUe = 1; // UEÎßàÎã§ ÌïúÍ∞úÏùò flow ÏÉùÏÑ±
    uint16_t dlPort = 1234;
    uint16_t ulPort = dlPort + gNbNum * ueNum * numFlowsUe + 1;

    ApplicationContainer clientApps;
    ApplicationContainer serverApps;

    bool disableDl = false;
    bool disableUl = false;
    uint32_t udpPacketSizeBe = 100;
    uint32_t lambdaUll = 2;

    uint16_t u = 0;
    if (!disableDl)
    { // Ïù¥Í≤å Î¨¥Ï°∞Í±¥ Ï≤òÏùå ÏÑ§ÏπòÌïú Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Î°ú Ìå®ÌÇ∑ÏùÑ Î≥¥ÎÉÑ
        PacketSinkHelper dlPacketSinkHelper("ns3::UdpSocketFactory",
                                            InetSocketAddress(Ipv4Address::GetAny(), dlPort));
        // UEÍ∞Ä ÏàòÏã†Ï™ΩÏûÑ (ÏßÄÏ†ïÎêú Ìè¨Ìä∏Î°ú Ïò§Îäî Ïñ¥Îñ§ Îç∞Ïù¥ÌÑ∞Îì†(GetAny) Î∞õÏïÑÏ§å)
        serverApps.Add(dlPacketSinkHelper.Install(ueNode.Get(u)));

        UdpClientHelper dlClient(ueUUIpIface.GetAddress(u),
                                 dlPort); // Î™©Ï†ÅÏßÄ(UE IP), Î™©Ï†ÅÏßÄ Ìè¨Ìä∏
        dlClient.SetAttribute("PacketSize",
                              UintegerValue(udpPacketSizeBe)); // Ìå®ÌÇ∑ ÌïòÎÇòÏùò ÌÅ¨Í∏∞
        dlClient.SetAttribute("Interval",
                              TimeValue(Seconds(1.0 / lambdaUll))); // Ï†ÑÏÜ° Ï£ºÍ∏∞(Ìå®ÌÇ∑ Ï†ÑÏÜ°Î•† Ï†úÏñ¥)
        dlClient.SetAttribute("MaxPackets",
                              UintegerValue(0xFFFFFFFF)); // ÏóÑÏ≤≠ÎÇòÍ≤å ÎßéÏùÄ Ìå®ÌÇ∑ 16ÏßÑÏàò
        clientApps.Add(dlClient.Install(remoteHost));

        Ptr<EpcTft> tft = Create<EpcTft>(); // Traffic Flow Template(ÌäπÏ†ï Ï°∞Í±¥ÏùÑ ÎßåÏ°±ÌïòÎäî Ìå®ÌÇ∑ÏùÑ
                                            // Ïñ¥Îñ§ BearerÏóê Îß§ÌïëÌï†ÏßÄ Í≤∞Ï†ï)
        EpcTft::PacketFilter dlpf;
        dlpf.localPortStart = dlPort;
        dlpf.localPortEnd = dlPort;
        ++dlPort; // Îã§Ïùå flowÏúÑÌï¥ Ìè¨Ìä∏Î≤àÌò∏ Ï¶ùÍ∞Ä => Ï¶â Í∞Å flowÎßàÎã§ Îã§Î•∏ Ìè¨Ìä∏ ÏÇ¨Ïö©Ï§ë
        tft->Add(dlpf);

        // QoSÌÅ¥ÎûòÏä§(QCI) Í≤∞Ï†ï
        enum EpsBearer::Qci q;

        q = EpsBearer::NGBR_VIDEO_TCP_PREMIUM;

        // EPS Bearer ÏÉùÏÑ± + ÌôúÏÑ±Ìôî
        EpsBearer bearer(q);
        nrHelper->ActivateDedicatedEpsBearer(ueUuNetDev.Get(u), bearer, tft);
    }

    if (!disableUl)
    {
        PacketSinkHelper ulPacketSinkHelper("ns3::UdpSocketFactory",
                                            InetSocketAddress(Ipv4Address::GetAny(), ulPort));
        serverApps.Add(ulPacketSinkHelper.Install(remoteHost));

        UdpClientHelper ulClient(remoteHostAddr, ulPort);
        ulClient.SetAttribute("PacketSize", UintegerValue(udpPacketSizeBe));
        ulClient.SetAttribute("Interval", TimeValue(Seconds(1.0 / lambdaUll)));
        ulClient.SetAttribute("MaxPackets", UintegerValue(0xFFFFFFFF));
        clientApps.Add(ulClient.Install(ueNode.Get(u)));

        Ptr<EpcTft> tft = Create<EpcTft>();
        EpcTft::PacketFilter ulpf;
        ulpf.remotePortStart = ulPort;
        ulpf.remotePortEnd = ulPort;
        ++ulPort;
        tft->Add(ulpf);

        enum EpsBearer::Qci q;
        q = EpsBearer::NGBR_VIDEO_TCP_PREMIUM;

        EpsBearer bearer(q);
        nrHelper->ActivateDedicatedEpsBearer(ueUuNetDev.Get(u), bearer, tft);
    }
    nrHelper->AttachToClosestEnb(ueUuNetDev, gnbNetDev);

    //------------------------end of UU setting------------------------------------------

    // SL Ï†ÑÏö© AddressHelper

    Ipv4AddressHelper slIpv4h;
    slIpv4h.SetBase ("10.1.0.0", "255.255.0.0");
    Ipv4InterfaceContainer ueSlIpIface = slIpv4h.Assign (ueSlNetDev);

    // OBUÏóêÏÑú SideLinkÏä§ÌÉùÏóêÏÑú ipÏÑ§Ïπò //todo : Ïó¨Í∏∞ sidelink Ïä§ÌÉù ÏÑ§Ïπò ÌõÑ rsrpÏ∏°Ï†ïÎêòÎÇò ÏïàÎêòÎÇò ÌôïÏù∏
    // Ipv4InterfaceContainer ueSlIpIface;
    // ueSlIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueSlNetDev));
    Address ueRemoteAddress;
    Address ueLocalAddress;
    Ipv4Address ueAddress4("225.0.0.0");
    uint16_t port = 8000;

    SidelinkInfo slInfo;
    slInfo.m_castType = SidelinkInfo::CastType::Unicast;
    slInfo.m_dstL2Id = 255;
    slInfo.m_rri = MilliSeconds(100);
    slInfo.m_pdb = Seconds(0); // delay budget
    slInfo.m_harqEnabled = true;

    for (uint32_t u = 0; u < ueSlNetDev.GetN(); ++u)
    {
        // Set the default gateway for the UE
        Ptr<Ipv4StaticRouting> ueStaticRouting =
            ipv4RoutingHelper.GetStaticRouting(ueSlNetDev.Get(u)->GetNode()->GetObject<Ipv4>());
        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);

        ueRemoteAddress = InetSocketAddress(ueAddress4, port);
        ueLocalAddress = InetSocketAddress(Ipv4Address::GetAny(), port);
        Ptr<LteSlTft> tft =
            Create<LteSlTft>(LteSlTft::Direction::BIDIRECTIONAL, ueAddress4, slInfo);
        // Set Sidelink bearers
        nrSlHelper->ActivateNrSlBearer(Seconds(1), ueSlNetDev, tft);
    }

    //rsu sidelinkÏä§ÌÉùÏóê ip ÏÑ§Ïπò todo:

    // RsuÏóêÏÑú SideLinkÏä§ÌÉùÏóêÏÑú ipÏÑ§Ïπò //todo : Ïó¨Í∏∞ sidelink Ïä§ÌÉù ÏÑ§Ïπò ÌõÑ rsrpÏ∏°Ï†ïÎêòÎÇò ÏïàÎêòÎÇò ÌôïÏù∏
    // Ipv4InterfaceContainer rsuSlIpIface;
    // rsuSlIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(RsuNetDev));
    internet.Install(rsuNode);
    Ipv4InterfaceContainer rsuSlIpIface = slIpv4h.Assign (RsuNetDev);
    Address rsuRemoteAddress;
    Address rsuLocalAddress;
    Ipv4Address groupAddress4("225.0.0.0");

    // SidelinkInfo slInfo;
    // slInfo.m_castType = SidelinkInfo::CastType::Unicast;
    // slInfo.m_dstL2Id = 255;
    // slInfo.m_rri = MilliSeconds(100);
    // slInfo.m_pdb = Seconds(0); // delay budget
    // slInfo.m_harqEnabled = true;

    for (uint32_t u = 0; u < RsuNetDev.GetN(); ++u)
    {
        // Set the default gateway for the UE
        Ptr<Ipv4StaticRouting> rsuStaticRouting =
            ipv4RoutingHelper.GetStaticRouting(RsuNetDev.Get(u)->GetNode()->GetObject<Ipv4>());
        rsuStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);

        rsuRemoteAddress = InetSocketAddress(groupAddress4, port);
        rsuLocalAddress = InetSocketAddress(Ipv4Address::GetAny(), port);
        Ptr<LteSlTft> tft =
            Create<LteSlTft>(LteSlTft::Direction::BIDIRECTIONAL, groupAddress4, slInfo);
        // Set Sidelink bearers
        nrSlHelper->ActivateNrSlBearer(Seconds(1), RsuNetDev, tft);
    }

    // Ptr<NrUeNetDevice> ueSlDev = DynamicCast<NrUeNetDevice>(ueSlNetDev.Get(0));
    // Ptr<NrUePhy> ueSlPhy = ueSlDev->GetPhy(0);
    // ueSlPhy->SetSlReport();
    //
    // Ptr<NrUeNetDevice> rsuSlDev = DynamicCast<NrUeNetDevice>(RsuNetDev.Get(0));
    // Ptr<NrUePhy> rsuSlPhy = rsuSlDev->GetPhy(0);
    // rsuSlPhy->SetSlReport();

    Ptr<NrUeNetDevice> ueDev = DynamicCast<NrUeNetDevice> (RsuNetDev.Get (0));
    Ptr<NrUePhy>       uePhy   = ueDev->GetPhy (0);
    uePhy->GetNrSlUeCphySapProvider ()->EnableUeSlRsrpMeasurements ();

    Ptr<NrUeNetDevice> rsuDev = DynamicCast<NrUeNetDevice> (ueSlNetDev.Get (0));
    Ptr<NrUePhy>       rsuPhy   = ueDev->GetPhy (0);
    rsuPhy->GetNrSlUeCphySapProvider ()->EnableUeSlRsrpMeasurements ();

    double udpAppStartTime = 0.4; // seconds

    // start UDP server and client apps
    serverApps.Start(Seconds(udpAppStartTime));
    clientApps.Start(Seconds(udpAppStartTime));
    serverApps.Stop(simTime);
    clientApps.Stop(simTime);

    // enable the traces provided by the nr module
    // nrHelper->EnableTraces();//nrÎ™®ÎìàÏóêÏÑú Ï†úÍ≥µÌïòÎäî ÎÇ¥Î∂Ä(PHY,MAX,RLC) Ìä∏Î†àÏù¥Ïä§

    FlowMonitorHelper flowmonHelper;
    NodeContainer endpointNodes;
    endpointNodes.Add(remoteHost);
    endpointNodes.Add(ueNode);

    Ptr<ns3::FlowMonitor> monitor =
        flowmonHelper.Install(endpointNodes); // Í∞Å ÎÖ∏Îìú Í∞ÑÏùò UDP flow Ï∂îÏ†Å
    // BinWidthÎäî ÌûàÏä§ÌÜ†Í∑∏Îû® ÌòïÌÉúÎ°ú Î∂ÑÌè¨ ÎÇòÌÉÄÎÇº Îïå Í∞ÑÍ≤©ÏùÑ Î™á Ï¥à Îã®ÏúÑÎ°ú ÎÇòÎàåÏßÄ
    monitor->SetAttribute("DelayBinWidth", DoubleValue(0.001)); // ÏßÄÏó∞ Ï∏°Ï†ï Íµ¨Í∞Ñ(1ms)
    monitor->SetAttribute("JitterBinWidth",
                          DoubleValue(0.001)); // ÏßÄÌÑ∞(Ìå®ÌÇ∑ Í∞Ñ Ï†ÑÏÜ° Í∞ÑÍ≤©Ïùò Î≥ÄÌôîÎüâ) Ï∏°Ï†ï Íµ¨Í∞Ñ(1ms)
    // Ìå®ÌÇ∑Ïù¥ Í∑úÏπôÏ†ÅÏúºÎ°ú Ïò§ÏßÄ ÏïäÍ≥† ÎèÑÏ∞©Ìï† Îïå Í∑∏ Î∂àÏïàÏ†ïÏÑ± Ï∏°Ï†ï
    monitor->SetAttribute("PacketSizeBinWidth",
                          DoubleValue(20)); // Ìå®ÌÇ∑ ÌÅ¨Í∏∞ ÌûàÏä§ÌÜ†Í∑∏Îû® Íµ¨Í∞Ñ(20Î∞îÏù¥Ìä∏ Îã®ÏúÑ)
                                            // Ìå®ÌÇ∑Ïùò ÌÅ¨Í∏∞Î•º Î™á Î∞îÏù¥Ìä∏ Îã®ÏúÑÎ°ú ÎÇòÎàåÏßÄ

    Simulator::Schedule(Seconds(1.0), &LogUeFlowInfo, ueNode.Get(0));
    // slÏóêÏÑúÎäî rsrpÍ∞Ä Ï∏°Ï†ïÍ≤∞Í≥ºÍ∞Ä ÏïÑÎãàÎãàÍπå Ïù¥Í±∞ Ïñ¥ÏºÄ Ìï¥Í≤∞ÌïòÏßÄ?
    // ÏùºÎã® gnb rsrpÏ∏°Ï†ïÎêòÎäîÏßÄ Î®ºÏ†Ä ÌôïÏù∏ „Ñ±„Ñ± Ìå®ÌÇ∑Í¥ÄÎ†® ÏÑ§Ï†ïÏù¥ ÏóÜÏñ¥ÏÑú ÏïàÎêòÎäîÎìØ
    Simulator::Stop(simTime);
    Simulator::Run();
    Simulator::Destroy();
}